# 8.1 MLFQ：基本规则
MLFQ 总是优先执行较高优先级的工作（即在较高级队列中的工作）。
# 8.2 尝试 1：如何改变优先级
- 规则 1：如果 A 的优先级 > B 的优先级，运行 A（不运行 B）。
- 规则 2：如果 A 的优先级 = B 的优先级，轮转运行A 和 B。
- 规则 3：工作进入系统时，放在最高优先级（最上层队列）。
- 规则 4a：工作用完整个时间片后，降低其优先级（移入下一个队列）。
- 如果工作在其时间片以内主动释放 CPU，则优先级不变。
> 如果不知道工作是短工作还是长工作，那么就在开始的时候假设其是短工作，并赋予最高优先级。如果确实是短工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长工作了。通过这种方式，MLFQ 近似于 SJF。

饥饿（starvation）问题。如果系统有“太多”交互型工作，就会不断占用CPU，导致长工作永远无法得到 CPU（它们饿死了）。
# 8.3 尝试 2：提升优先级
- 规则 5：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。
> 如果 S 设置得太高，长工作会饥饿；如果设置得太低，交互型工作又得不到合适的 CPU 时间比例。
# 8.4 尝试 3：更好的计时方式 
我们重写规则 4a 和 4b。
- 规则 4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级（移入低一级队列）。