## 虚拟内存的作用

- 虚拟内存可以使得进程对**运行内存超过物理内存大小**，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。
- 由于每个进程都有自己的页表，所以**每个进程的虚拟内存空间就是相互独立的**。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。
- 页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如**控制一个页的读写权限**，标记该页是否存在等。在内存访问方面，操作系统提供了更好的**安全性**。
![[Pasted image 20250906231515.png]]

## 内存回收的过程是怎样的

![[Pasted image 20250906232328.png]]

CPU 去访问虚拟内存发生缺页中断的时候，会进入内核态找一块空闲的内存，这个时候如果空闲的内存不够的时候就会开始**内存回收**工作，回收的方式主要是两种：直接内存回收和后台内存回收。
- **后台内存回收**（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程**异步**的，不会阻塞进程的执行。
- **直接内存回收**（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是**同步**的，会阻塞进程的执行。

如果直接内存回收也无法清理出足够的空闲内存，那么就会触发OOM，开始杀进程了。进程被杀的优先级受到两方面的影响：
- 进程已经使用的物理内存页面数。
- 每个进程的 OOM 校准值 oom_score_adj。它是可以通过 `/proc/[pid]/oom_score_adj` 来配置的。（如果设置了-1000就不会被杀）
## 哪些内存可以被回收？
-  **文件页**：大部分文件也都可以直接释放内存，等要用的时候再从硬盘中读取出来，只有脏的文件叶需要写入硬盘然后再释放内存。
- **匿名叶**：这部分内存没有实际载体，比如堆、栈数据等。它们**回收的方式是通过 Linux 的 Swap 机制**，先保存到硬盘中，要用的时候再从硬盘中读取。

内存页回收遵循LRU算法，最近访问过的放在后面，最远访问的放在前面优先回收。
## 回收内存带来的性能影响

- 后台回收：异步回收，不会阻塞进程，影响较小。
- 直接回收：同步回收，会阻塞进程，影响比较大。

- 文件页回收：如果是感觉的文件页可以直接释放内存，影响很小，如果是脏页回收需要I/O，对性能影响比较大。
- 匿名页回收：Swap机制回收内存，需要磁盘I/O，对性能影响比较大。
### 尽早触发 kswapd 内核线程异步回收内存
![[Pasted image 20250906233437.png]]
kswapd 会**定期扫描内存**的使用情况，根据剩余内存（pages_free）的情况来进行内存回收的工作。
- 图中绿色部分：如果剩余内存（pages_free）大于 页高阈值（pages_high），说明剩余内存是充足的；
- 图中蓝色部分：如果剩余内存（pages_free）在页高阈值（pages_high）和页低阈值（pages_low）之间，说明内存有一定压力，但还可以满足应用程序申请内存的请求；
- 图中橙色部分：**这时 kswapd0 会执行内存回收，直到剩余内存大于高阈值（pages_high）为止**。虽然会触发内存回收，但是不会阻塞应用程序
- 此时就会**触发直接内存回收**，这时应用程序就会被阻塞

如果系统时不时发生抖动，观察到 pgscand（应用程序在内存申请过程中每秒直接扫描的 page 个数） 数值很大，那大概率是因为直接内存回收导致的，这时可以增大 min_free_kbytes 这个配置选项来及早地触发后台回收