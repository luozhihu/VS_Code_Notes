![[Pasted image 20250906205129.png]]

- 进程在用户态时，只能访问用户空间内存；
- 只有进入内核态后，才可以访问内核空间的内存；

## malloc函数是如何实现的

- 进程在用户态时，只能访问用户空间内存；
- 只有进入内核态后，才可以访问内核空间的内存；

方式一实现的方式很简单，就是通过 brk() 函数将「堆顶」指针向高地址移动，获得新的内存空间。
![[Pasted image 20250906205334.png]]

方式二通过 mmap() 系统调用中「私有匿名映射」的方式，在文件映射区分配一块内存，也就是从文件映射区“偷”了一块内存。如下图：
![[Pasted image 20250906205352.png]]

- 如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；
- 如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；

## malloc() 分配的是物理内存吗？

不是的，**malloc() 分配的是虚拟内存**。

只有在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，发现虚拟内存对应的页没有在物理内存中，就会触发缺页中断，然后操作系统会建立虚拟内存和物理内存之间的映射关系。

## free 释放内存，会归还给操作系统吗？

- malloc 通过 **brk()** 方式申请的内存，free 释放内存的时候，**并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用**；
- malloc 通过 **mmap()** 方式申请的内存，free 释放内存的时候，**会把内存归还给操作系统，内存得到真正的释放**。

- **小内存、频繁请求**：主要靠 `brk` 管理的堆区。用户态搞定，速度快如闪电。
- **大内存（通常超过一个阈值，比如几百KB）**：直接用 `mmap` 单独映射一块。这样避免了在堆区造成难以忍受的大洞（外部碎片），释放时也能干净利落地立刻归还给系统，不拖累堆区。

## malloc如何管理内存

![[Pasted image 20250906221541.png]]

- 申请内存，从空闲内存块中找到一块足够大的分配
- 释放内存，将内存释放并且合并前后的空闲内存块
