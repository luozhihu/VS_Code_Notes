# 7.1 工作负载假设 
1. 每一个工作运行相同的时间。
2. 所有的工作同时到达。
3. 一旦开始，每个工作保持运行直到完成。
4. 所有的工作只是用 CPU（即它们不执行 IO 操作）
5. 每个工作的运行时间是已知的。
# 7.2 调度指标 
$T_{周转时间}= T_{完成时间}−T_{到达时间}$
# 7.3 先进先出（FIFO） 
最短任务优先代表一个总体调度原则，可以应用于所有系统，只要其中平均客户（或在我们案例中的任务）周转时间很重要。
# 最短任务优先（SJF）
现在假设工作可以随时到达,在这种情况下存在缺陷。
# 7.5 最短完成时间优先（STCF） 
每当新工作进入系统时，它就会确定剩余工作和新工作中，谁的剩余时间最少，然后调度该工作。
# 7.6 新度量指标：响应时间 
$T_{响应时间}= T_{ 首次运行}−T_{到达时间}$

你可能会想，STCF 和相关方法在响应时间上并不是很好。例如，如果 3 个工作同时到达，第三个工作必须等待前两个工作全部运行后才能运行。这种方法虽然有很好的周转时间，但对于响应时间和交互性是相当糟糕的。
# 7.7 轮转（RR）
- 时间片长度必须是时钟中断周期的倍数
- RR越短在响应时间上表现越好。然而，时间片太短是有问题的：突然上下文切换的成本将影响整体性能。
- 如果响应时间是我们的唯一指标，那么带有合理时间片的 RR，就会是非常好的调度程序。
- 如果周转时间是我们的指标，那么 RR 确实是最糟糕的策略之一。
> 你可以运行较短的工作直到完成，但是要以响应时间为代价。如果你重视公平性，则响应时间会较短，但会以周转时间为代价。这种权衡在系统中很常见。你不能既拥有你的蛋糕，又吃它。
# 7.8 结合 I/O
 当这些交互式作业正在执行 I/O 时，其他 CPU 密集型作业将运行，从而更好地利用处理器。
# 7.9 无法预知
事实上，在一个通用的操作系统中（比如我们所关心的操作系统），操作系统通常对每个作业的长度知之甚少。因此，我们如何建立一个没有这种先验知识的 SJF/STCF？更进一步，我们如何能够将已经看到的一些想法与 RR 调度程序结合起来，以便响应时间也变得相当不没？ 